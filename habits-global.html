<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Habit Log | Global Overview</title>
  <link rel="icon" type="image/png" href="pics/earth.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
<nav class="site-nav">
  <div class="site-nav-links">
    <a href="index.html">Home</a>
    <a href="blog.html">Blog</a>
  </div>
  <button class="theme-toggle" id="theme-toggle" aria-label="Toggle color mode" type="button">ðŸŒ™</button>
</nav>

<header class="page-header">
  <div class="header-row">
    <h1>Habit Health</h1>
  </div>
  <h3 style="font-weight: normal;">Global view of the past 30 days per habit.</h3>
  <p style="margin-top: -10px;">Static prototype for now &mdash; Supabase wiring will replace the hard-coded data.</p>
</header>

<section id="global-status" class="card" style="display: none;"></section>

<section class="habit-nav" id="habit-selector"></section>

<section id="habit-detail" class="habit-grid"></section>

<script>
  const defaultApiBase = window.location.hostname === 'localhost' ? 'http://localhost:4100/api' : '/api';
  const API_BASE = window.TRACKING_API_BASE || defaultApiBase;

  (function () {
    const storageKey = 'sb-theme';
    const body = document.body;
    const toggle = document.getElementById('theme-toggle');

    const updateToggle = (isDark) => {
      toggle.innerHTML = '<span class="toggle-icon">â˜€</span>';
      toggle.setAttribute('aria-label', isDark ? 'Switch to light mode' : 'Switch to dark mode');
    };

    const applyTheme = (isDark) => {
      body.classList.toggle('dark-mode', isDark);
      updateToggle(isDark);
    };

    const storedPreference = localStorage.getItem(storageKey);
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const startDark = storedPreference ? storedPreference === 'dark' : prefersDark;
    applyTheme(startDark);

    toggle.addEventListener('click', () => {
      const makeDark = !body.classList.contains('dark-mode');
      applyTheme(makeDark);
      localStorage.setItem(storageKey, makeDark ? 'dark' : 'light');
    });
  })();

  (function () {
    const statusMeta = {
      complete: { label: 'Complete', icon: 'âœ”', description: 'Hit or exceeded target', className: 'status-complete' },
      partial: { label: 'In progress', icon: 'âˆ¼', description: 'Partial credit for the day', className: 'status-partial' },
      missed: { label: 'Missed', icon: 'âœ–', description: 'No entry logged', className: 'status-missed' }
    };

    const formatDate = (value) => {
      const d = new Date(value);
      if (Number.isNaN(d.getTime())) {
        return value;
      }
      return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
    };

    const toggleStatusCard = (message, isError = false) => {
      const statusEl = document.getElementById('global-status');
      if (!message) {
        statusEl.style.display = 'none';
        statusEl.textContent = '';
        statusEl.classList.remove('is-error');
        return;
      }
      statusEl.textContent = message;
      statusEl.style.display = 'block';
      statusEl.classList.toggle('is-error', Boolean(isError));
    };

    let trackersCache = [];
    let selectedId = null;

    const formatValue = (tracker, value) => {
      if (value === null || value === undefined || Number.isNaN(value)) {
        return 'n/a';
      }
      const stringValue = typeof value === 'number' && !Number.isInteger(value) ? value.toFixed(1) : value;
      return tracker.unit ? `${stringValue} ${tracker.unit}`.trim() : stringValue;
    };

    const buildCalendar = (tracker) => {
      const calendarCells = (tracker.history || [])
        .map((entry) => {
          const meta = statusMeta[entry.status] ?? statusMeta.missed;
          return `<div class="calendar-day ${meta.className}" title="${formatDate(entry.date)} â€“ ${meta.label}">${meta.icon}</div>`;
        })
        .join('');
      return `
        <div class="habit-calendar" role="list" aria-label="${tracker.label} history">
          ${calendarCells}
        </div>`;
    };

    const buildLineChart = (tracker) => {
      const points = (tracker.history || []).filter((entry) => typeof entry.numericValue === 'number');
      if (!points.length) {
        return '<p class="chart-empty">No numeric entries yet.</p>';
      }
      const values = points.map((entry) => entry.numericValue);
      const min = Math.min(...values);
      const max = Math.max(...values);
      const range = max - min || 1;
      const width = 760;
      const height = 260;
      const padding = 45;
      const innerWidth = width - padding * 2;
      const innerHeight = height - padding * 2;
      const polylinePoints = points
        .map((entry, index) => {
          const x = points.length === 1 ? width / 2 : (index / (points.length - 1)) * innerWidth + padding;
          const normalised = (entry.numericValue - min) / range;
          const y = height - padding - normalised * innerHeight;
          return `${x},${y}`;
        })
        .join(' ');

      const latest = points[points.length - 1];
      const avg = values.reduce((sum, value) => sum + value, 0) / values.length;

      const yTicks = 3;
      const yTickLines = Array.from({ length: yTicks + 1 }, (_, idx) => {
        const value = min + (range * idx) / yTicks;
        const y = height - padding - (idx / yTicks) * innerHeight;
        return { y, label: formatValue(tracker, value), value };
      });

      const xTickCount = Math.min(4, points.length - 1);
      const xTickLines = xTickCount <= 0
        ? []
        : Array.from({ length: xTickCount + 1 }, (_, idx) => {
            const position = (idx / xTickCount) * (points.length - 1);
            const pointIndex = Math.round(position);
            const x = (pointIndex / (points.length - 1)) * innerWidth + padding;
            const label = formatDate(points[pointIndex].date);
            return { x, label };
          });

      let targetLine = null;
      const rawTarget = tracker.target;
      let targetValue = null;
      if (typeof rawTarget === 'number') {
        targetValue = rawTarget;
      } else if (typeof rawTarget === 'string' && rawTarget.trim() !== '') {
        const parsed = Number(rawTarget);
        if (Number.isFinite(parsed)) {
          targetValue = parsed;
        }
      }
      if (Number.isFinite(targetValue)) {
        const normalisedTarget = (targetValue - min) / range;
        targetLine = height - padding - normalisedTarget * innerHeight;
        targetLine = Math.max(padding, Math.min(height - padding, targetLine));
      }

      return `
        <div class="habit-chart">
          <svg viewBox="0 0 ${width} ${height}" role="img" aria-label="${tracker.label} last values">
            <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" class="chart-axis" />
            <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${height - padding}" class="chart-axis" />
            ${yTickLines
              .map(
                (tick) => `
                  <line x1="${padding - 4}" y1="${tick.y}" x2="${width - padding}" y2="${tick.y}" class="chart-tick" />
                  <text x="${padding - 8}" y="${tick.y + 4}" class="chart-label" text-anchor="end">${tick.label}</text>`
              )
              .join('')}
            ${xTickLines
              .map(
                (tick) => `
                  <line x1="${tick.x}" y1="${height - padding}" x2="${tick.x}" y2="${height - padding + 6}" class="chart-tick" />
                  <text x="${tick.x}" y="${height - padding + 20}" class="chart-label" text-anchor="middle">${tick.label}</text>`
              )
              .join('')}
            ${targetLine !== null
              ? `<line x1="${padding}" y1="${targetLine}" x2="${width - padding}" y2="${targetLine}" class="chart-target" />`
              : ''}
            <polyline points="${polylinePoints}" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round" stroke-linecap="round" />
          </svg>
          <div class="chart-meta">
            <div>
              <small>Last entry</small>
              <strong>${formatValue(tracker, latest.numericValue)}</strong>
              <span>${formatDate(latest.date)}</span>
            </div>
            <div>
              <small>30-day avg</small>
              <strong>${formatValue(tracker, avg)}</strong>
            </div>
          </div>
        </div>`;
    };

    const renderDetail = (tracker) => {
      const container = document.getElementById('habit-detail');
      container.innerHTML = '';
      if (!tracker) {
        container.innerHTML = '<p>Select a habit to view history.</p>';
        return;
      }

      const article = document.createElement('article');
      article.className = 'habit-card card';
      const headerFragment = `
        <header class="habit-card-header">
          <div>
            <div class="habit-title">
              <span class="habit-icon" aria-hidden="true">${tracker.icon || ''}</span>
              <div>
                <h3>${tracker.label}</h3>
                <p>${tracker.description || tracker.detail || ''}</p>
              </div>
            </div>
          </div>
          <div class="habit-tally">
            <strong>${tracker.summary?.recentWins ?? 0}/7</strong>
            <span>past 7 days</span>
            <small>${tracker.summary?.completionRate ?? 0}% last 30</small>
          </div>
        </header>`;

      const calendarCells = (tracker.history || [])
        .map((entry) => {
          const meta = statusMeta[entry.status] ?? statusMeta.missed;
          return `<div class="calendar-day ${meta.className}" title="${formatDate(entry.date)} â€“ ${meta.label}">${meta.icon}</div>`;
        })
        .join('');

      const bodyFragment = tracker.type === 'checkbox' ? buildCalendar(tracker) : buildLineChart(tracker);

      article.innerHTML = headerFragment + bodyFragment;
      container.appendChild(article);
    };

    const renderSelector = () => {
      const selector = document.getElementById('habit-selector');
      selector.innerHTML = '';
      trackersCache.forEach((tracker) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'habit-nav-button';
        if (tracker.id === selectedId) {
          button.classList.add('is-active');
        }
        button.innerHTML = `<span class="habit-nav-icon">${tracker.icon || ''}</span><span>${tracker.label}</span>`;
        button.addEventListener('click', () => {
          selectedId = tracker.id;
          renderSelector();
          renderDetail(trackersCache.find((item) => item.id === selectedId));
        });
        selector.appendChild(button);
      });
    };

    const loadGlobalSnapshot = async () => {
      toggleStatusCard('Loading tracking historyâ€¦');
      try {
        const response = await fetch(`${API_BASE}/trackers/global?days=30`);
        if (!response.ok) {
          throw new Error('Request failed');
        }
        const payload = await response.json();
        if (!payload.ok) {
          throw new Error(payload.error || 'Failed to load data');
        }
        toggleStatusCard();
        trackersCache = payload.data?.trackers ?? [];
        if (!trackersCache.length) {
          toggleStatusCard('No trackers configured yet.');
          return;
        }
        selectedId = trackersCache[0].id;
        renderSelector();
        renderDetail(trackersCache[0]);
      } catch (error) {
        console.error(error);
        toggleStatusCard('Unable to load history right now.', true);
      }
    };

    loadGlobalSnapshot();
  })();
</script>
</body>
</html>
